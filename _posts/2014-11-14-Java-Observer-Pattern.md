---
layout: post
title: Java观察者模式（Observer）
category: Design Pattern
date: 2014-11-14
---

#定义
---
定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新；观察者模式是一种对象行为型模式。

#概述
---
观察者模式是使用频率最高的设计模式之一，它用于建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应作出反应。在观察者模式中，**发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间可以没有任何相互联系**，可以根据需要增加和删除观察者，使得系统更易于扩展。

“红灯停，绿灯行”，在日常生活中，交通信号灯装点着我们的城市，指挥着日益拥挤的城市交通。当红灯亮起，来往的汽车将停止；而绿灯亮起，汽车可以继续前行。在这个过程中，交通信号灯是汽车（更准确地说应该是汽车驾驶员）的观察目标，而汽车是观察者。随着交通信号灯的变化，汽车的行为也将随之而变化，一盏交通信号灯可以指挥多辆汽车。

在软件系统中，有些对象之间也存在类似交通信号灯和汽车之间的关系，一个对象的状态或行为的变化将导致其他对象的状态或行为也发生改变，它们之间将产生联动，正所谓“触一而牵百发”。为了更好地描述对象之间存在的这种一对多（包括一对一）的联动，观察者模式应运而生，它定义了对象之间一种一对多的依赖关系，让一个对象的改变能够影响其他对象。本章我们将学习用于实现对象间联动的观察者模式。

<!-- more -->

#适用性
---
在以下情况下可以考虑使用观察者模式：

1. 一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两个方面封装在独立的对象中使它们可以各自独立地改变和复用。
2. 一个对象的改变将导致一个或多个其他对象也发生改变，而并不知道具体有多少对象将发生改变，也不知道这些对象是谁。
3. 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象...，可以使用观察者模式创建一种链式触发机制。

#结构
---
观察者模式结构中通常包括观察目标和观察者两个继承层次结构，其结构如图1所示：
![structure](/media/files/pattern/observer/structure.png)
<div align="center">图1 观察者模式结构图</div>

#角色
---
**Subject（目标）**
目标又称为主题，它是被观察的对象。在目标中定义了一个观察者集合，一个观察目标可以接受任意数量的观察者来观察，它提供一系列方法来增加和删除观察者对象，同时它定义了通知方法`notify()`；目标类可以是接口，也可以是抽象类或具体类。

**ConcreteSubject（具体目标）**
具体目标是目标类的子类，通常它包含有经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知；同时它还实现了在目标类中定义的抽象业务逻辑方法（如果有的话）；如果无须扩展目标类，则具体目标类可以省略。

**Observer（观察者）**
观察者将对观察目标的改变做出反应，观察者一般定义为接口，该接口声明了更新数据的方法`update()`，因此又称为抽象观察者。

**ConcreteObserver（具体观察者）**
在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致；它实现了在抽象观察者`Observer`中定义的`update()`方法。通常在实现时，可以调用具体目标类的`attach()`方法将自己添加到目标类的集合中或通过`detach()`方法将自己从目标类的集合中删除。

#协作
---
**观察者模式描述了如何建立对象与对象之间的依赖关系，以及如何构造满足这种需求的系统**。

观察者模式包含观察目标和观察者两类对象，一个目标可以有任意数目的与之相依赖的观察者，一旦观察目标的状态发生改变，所有的观察者都将得到通知。作为对这个通知的响应，每个观察者都将监视观察目标的状态以使其状态与目标状态同步，这种交互也称为**发布-订阅(Publish-Subscribe)**。
观察目标是通知的发布者，它发出通知时并不需要知道谁是它的观察者，可以有任意数目的观察者订阅它并接收通知。

下面通过示意代码来对该模式进行进一步分析。首先我们定义一个抽象目标`Subject`，典型代码如下所示：

{% highlight java %}
public abstract class Subject {
    // 定义一个观察者集合用于存储所有观察者对象
    protected List<Observer> observers = new ArrayList<Observer>();
    
    // 注册方法，用于向观察者集合中增加一个观察者
    public void attach(Observer observer) {
        observers.add(observer);
    }
    
    // 注销方法，用于在观察者集合中删除一个观察者
    public void detach(Observer observer) {
        observers.remove(observer);
    }
    
    // 声明抽象通知方法
    public abstract void notify();
}
{% endhighlight %}

具体目标类`ConcreteSubject`是实现了抽象目标类`Subject`的一个具体子类，其典型代码如下所示：
{% highlight java %}
public class ConcreteSubject extends Subject {
    // 实现通知方法
    public void notify() {
        // 遍历观察者集合，调用每一个观察者的响应方法
        for (Observer obs : observers) {
            obs.update();
        }
    }
}
{% endhighlight %}

抽象观察者角色一般定义为一个接口，通常只声明一个`update()`方法，为不同观察者的更新（响应）行为定义相同的接口，这个方法在其子类中实现，不同的观察者具有不同的响应方法。抽象观察者`Observer`典型代码如下所示：
{% highlight java %}
public interface Observer {
    // 声明响应方法
    public void update();
}
{% endhighlight %}

在具体观察者`ConcreteObserver`中实现了`update()`方法，其典型代码如下所示：
{% highlight java %}
public class ConcreateObserver implements Observer {
    // 实现响应方法
    public void update() {
        // 具体响应代码    
    }
}
{% endhighlight %}

在有些更加复杂的情况下，**具体观察者类`ConcreteObserver`的`update()`方法在执行时需要使用到具体目标类`ConcreteSubject`中的状态（属性）**，因此在`ConcreteObserver`与`ConcreteSubject`之间有时候还存在关联或依赖关系，在`ConcreteObserver`中定义一个`ConcreteSubject`实例，通过该实例获取存储在`ConcreteSubject`中的状态。

如果`ConcreteObserver`的`update()`方法不需要使用到`ConcreteSubject`中的状态属性，则可以对观察者模式的标准结构进行简化，在具体观察者`ConcreteObserver`和具体目标`ConcreteSubject`之间无须维持对象引用。

如果在具体层具有关联关系，系统的扩展性将受到一定的影响，增加新的具体目标类有时候需要修改原有观察者的代码，在一定程度上违反了“开闭原则”，但是如果原有观察者类无须关联新增的具体目标，则系统扩展性不受影响。

#效果
---
观察者模式是一种使用频率非常高的设计模式，无论是移动应用、Web应用或者桌面应用，观察者模式几乎无处不在，它为实现对象之间的联动提供了一套完整的解决方案，凡是涉及到一对一或者一对多的对象交互场景都可以使用观察者模式。观察者模式广泛应用于各种编程语言的GUI事件处理的实现，在基于事件的XML解析技术（如SAX2）以及Web事件处理中也都使用了观察者模式。

观察者模式的主要优点如下：

- 观察者模式可以实现表示层和数据逻辑层的分离，定义了稳定的消息更新传递机制，并抽象了更新接口，使得可以有各种各样不同的表示层充当具体观察者角色。
- 观察者模式在观察目标和观察者之间建立一个抽象的耦合。观察目标只需要维持一个抽象观察者的集合，无须了解其具体观察者。由于观察目标和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次。
- 观察者模式支持广播通信，观察目标会向所有已注册的观察者对象发送通知，简化了一对多系统设计的难度。
- 观察者模式满足“开闭原则”的要求，增加新的具体观察者无须修改原有系统代码，在具体观察者与观察目标之间不存在关联关系的情况下，增加新的观察目标也很方便。

观察者模式的主要缺点如下：

- 如果一个观察目标对象有很多直接和间接观察者，将所有的观察者都通知到会花费很多时间。
- 如果在观察者和观察目标之间存在循环依赖，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。
- 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。

#实例：多人联机对战游戏的设计
---
> Sunny软件公司欲开发一款多人联机对战游戏（类似魔兽世界、星际争霸等游戏），在该游戏中，多个玩家可以加入同一战队组成联盟，当战队中某一成员受到敌人攻击时将给所有其他盟友发送通知，盟友收到通知后将作出响应。
> Sunny软件公司开发人员需要提供一个设计方案来实现战队成员之间的联动。

Sunny软件公司开发人员通过对系统功能需求进行分析，发现在该系统中战队成员之间的联动过程可以简单描述如下：

> 联盟成员受到攻击 --> 发送通知给盟友 --> 盟友作出响应

如果按照上述思路来设计系统，由于联盟成员在受到攻击时需要通知他的每一个盟友，因此每个联盟成员都需要持有其他所有盟友的信息，这将导致系统开销较大，因此Sunny公司开发人员决定引入一个新的角色：“战队控制中心”，来负责维护和管理每个战队所有成员的信息。
当一个联盟成员受到攻击时，将向相应的战队控制中心发送求助信息，战队控制中心再逐一通知每个盟友，盟友再作出响应；受攻击的联盟成员将与战队控制中心产生联动，战队控制中心还将与其它盟友产生联动。

如何实现对象之间的联动？如何让一个对象的状态或行为改变时，依赖于它的对象能够得到通知并进行相应的处理？本章所介绍的观察者模式将为对象之间的联动提供一个优秀的解决方案。

**解决方案**

为了实现对象之间的联动，Sunny软件公司开发人员决定使用观察者模式来进行多人联机对战游戏的设计，其基本结构如图2所示：
![online_game](/media/files/pattern/observer/online_game.png)
<div align="center">图2 多人联机对战游戏结构图</div>

在图2中，`AllyControlCenter`充当目标类，`ConcreteAllyControlCenter`充当具体目标类，`Observer`充当抽象观察者，`Player`充当具体观察者。

完整代码托管在Github：[OnlineGame](https://github.com/2dxgujun/java-design-patterns/tree/master/src/behavioral/observer/game)

编译并运行程序，输出结果如下：

> 战队创建成功<br>
> --------------------------<br>
> Player1加入基地组织战队<br>
> Player2加入基地组织战队<br>
> Player3加入基地组织战队<br>
> Player4加入基地组织战队<br>
> Player1被攻击<br>
> 基地组织战队通知：盟友Player1遭受敌人攻击<br>
> Player2赶来支援<br>
> Player3赶来支援<br>
> Player4赶来支援<br>

在本实例中，实现了两次对象之间的联动，当一个游戏玩家`Player`对象的`beAttacked()`方法被调用时，将调用`AllyControlCenter`的`notifyObserver()`方法来进行处理，而在`notifyObserver()`方法中又将调用其他`Player`对象的`help()`方法。

`Player`的`beAttacked()`方法、`AllyControlCenter`的`notifyObserver()`方法以及`Player`的`help()`方法构成了一个联动触发链，执行顺序如下所示：

> Player.beAttacked() --> AllyControlCenter.notifyObserver() -->Player.help()。

#JDK对观察者模式的支持
---
观察者模式在Java语言中的地位非常重要。在JDK的java.util包中，提供了`Observable`类以及`Observer`接口，它们构成了JDK对观察者模式的支持。如图3所示：
![jdk](/media/files/pattern/observer/jdk.png)
<div align="center">图3 JDK提供的Observable类及Observer接口结构图</div>

##Observer接口
在java.util.Observer接口中只声明一个方法，它充当抽象观察者，其方法声明代码如下所示：

> void update(Observable observable, Object data);

当观察目标的状态发生变化时，该方法将会被调用，在`Observer`的子类中将实现`update()`方法，即具体观察者可以根据需要具有不同的更新行为。当调用观察目标类`Observable`的`notifyObservers()`方法时，将执行观察者类中的`update()`方法。

##Observable类
java.util.Observable类充当观察目标类，在`Observable`中定义了一个向量`Vector`来存储观察者对象。`Observable`类除了包含注册和删除观察者对象的方法和通知观察对象的方法，还设置了一个标记变量changed，用于标识观察的目标对象的内部状态是否发生改变。

我们**可以直接使用`Observer`接口和`Observable`类来作为观察者模式的抽象层，再自定义具体观察者类和具体观察目标类**，通过使用JDK中的`Observer`接口和`Observable`类，可以更加方便地在Java语言中应用观察者模式。

#观察者模式与Java事件处理
---
JDK 1.0及更早版本的事件模型基于职责链模式，但是这种模型不适用于复杂的系统，因此在JDK 1.1及以后的各个版本中，事件处理模型采用**基于观察者模式的委派事件模型**(DelegationEvent Model, DEM)，即**一个Java组件所引发的事件并不由引发事件的对象自己来负责处理，而是委派给独立的事件处理对象负责**。

在DEM模型中，目标角色（如界面组件）负责发布事件，而观察者角色（事件处理者）可以向目标订阅它所感兴趣的事件。当一个具体目标产生一个事件时，它将通知所有订阅者。
事件的发布者称为**事件源**(Event Source)，而订阅者称为**事件监听器**(Event Listener)，在这个过程中还可以通过**事件对象**(Event Object)来传递与事件相关的信息，可以在事件监听者的实现类中实现事件处理，因此事件监听对象又可以称为事件处理对象。

**事件源对象、事件监听对象（事件处理对象）和事件对象构成了Java事件处理模型的三要素**。事件源对象充当观察目标，而事件监听对象充当观察者。

以按钮点击事件为例，其事件处理流程如下：

1. 如果用户在GUI中单击一个按钮，将触发一个事件（如`ActionEvent`类型的动作事件），JVM将产生一个相应的`ActionEvent`类型的事件对象，在该事件对象中包含了有关事件和事件源的信息，此时按钮是事件源对象；
2. 将`ActionEvent`事件对象传递给事件监听对象（事件处理对象），JDK提供了专门用于处理`ActionEvent`事件的接口`ActionListener`，开发人员需提供一个`ActionListener`的实现类（如`MyActionHandler`），实现在`ActionListener`接口中声明的抽象事件处理方法`actionPerformed()`，对所发生事件做出相应的处理；
3. 开发人员将`ActionListener`接口的实现类（如`MyActionHandler`）对象注册到按钮中，可以通过按钮类的`addActionListener()`方法来实现注册；
4.  JVM在触发事件时将调用按钮的`fireXXX()`方法，在该方法内部将调用注册到按钮中的事件处理对象的`actionPerformed()`方法，实现对事件的处理。

使用类似的方法，我们可自定义GUI组件，如包含两个文本框和两个按钮的登录组件`LoginBean`，可以采用如图4所示设计方案：

![login](/media/files/pattern/observer/login.png)
<div align="center">图4 自定义登录组件结构图（省略按钮、文本框等界面组件）</div>

图4中相关类说明如下：

1. **LoginEvent**：事件类；它用于封装与事件有关的信息，它不是观察者模式的一部分，但是它可以在目标对象和观察者对象之间传递数据，在AWT事件模型中，所有的自定义事件类都是java.util.EventObject的子类。
2. **LoginEventListener**：抽象观察者；它声明了事件响应方法`validateLogin()`，用于处理事件，该方法也称为事件处理方法，`validateLogin()`方法将一个`LoginEvent`类型的事件对象作为参数，用于传输与事件相关的数据，在其子类中实现该方法，实现具体的事件处理。
3. **LoginBean**：具体目标类；在这里我们没有定义抽象目标类，对观察者模式进行了一定的简化。在`LoginBean`中定义了抽象观察者`LoginEventListener`类型的对象lel和事件对象`LoginEvent`，提供了注册方法`addLoginEventListener()`用于添加观察者，**在Java事件处理中，通常使用的是一对一的观察者模式，而不是一对多的观察者模式**，也就是说，一个观察目标中只定义一个观察者对象，而不是提供一个观察者对象的集合。在`LoginBean`中还定义了通知方法`fireLoginEvent()`，该方法在Java事件处理模型中称为“点火方法”，在该方法内部实例化了一个事件对象`LoginEvent`，将用户输入的信息传给观察者对象，并且调用了观察者对象的响应方法`validateLogin()`。
4. **LoginValidatorA**和**LoginValidatorB**：具体观察者类；它们实现了在`LoginEventListener`接口中声明的抽象方法`validateLogin()`，用于具体实现事件处理，该方法包含一个`LoginEvent`类型的参数，在`LoginValidatorA`和`LoginValidatorB`类中可以针对相同的事件提供不同的实现。

#观察者模式与MVC
---
在当前流行的MVC(Model-View-Controller)架构中也应用了观察者模式，MVC是一种架构模式，它包含三个角色：模型(Model)，视图(View)和控制器(Controller)。其中模型可对应于观察者模式中的观察目标，而视图对应于观察者，控制器可充当两者之间的中介者。当模型层的数据发生改变时，视图层将自动改变其显示内容。如图5所示：

![mvc](/media/files/pattern/observer/mvc.jpg)
<div align="center">图5 MVC结构示意图</div>

在图5中，模型层提供的数据是视图层所观察的对象，在视图层中包含两个用于显示数据的图表对象，一个是柱状图，一个是饼状图，相同的数据拥有不同的图表显示方式，如果模型层的数据发生改变，两个图表对象将随之发生变化，这意味着图表对象依赖模型层提供的数据对象，因此数据对象的任何状态改变都应立即通知它们。

同时，这两个图表之间相互独立，不存在任何联系，而且图表对象的个数没有任何限制，用户可以根据需要再增加新的图表对象，如折线图。在增加新的图表对象时，无须修改原有类库，满足“开闭原则”。

PS：<br>
Android框架中的游标装载器（CursorLoader）、Cursor、ContentResolver之间就是应用的观察者模式；当底层数据发生改变（进行增删改操作）时，目标就会通知装载器使其加载最新的数据。我在另一篇文章中从源码的角度详细分析了这种机制的实现：[Cursor和CursorLoader中的观察者模式](/post/2014/11/14/Observer-between-Cursor-and-CursorLoader.html)。


<br/>
参考：

1. [史上最强设计模式导学目录](http://blog.csdn.net/lovelion/article/details/17517213)
2. 《设计模式——可复用面向对象软件的基础》

本文出自[2dxgujun](/)，转载时请注明出处及相应链接。